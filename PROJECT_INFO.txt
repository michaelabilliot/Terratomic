# Project Info: Terratomic (Version 2.0 - Code-Verified)

This document provides a deep technical overview of the Terratomic project, verified and enhanced against the provided source code. It is intended to onboard developers and serve as a comprehensive reference for the game's architecture and mechanics.

## 1. Project Overview

Terratomic is a real-time strategy (RTS) game focused on territorial conquest, resource management, and diplomacy. The game is a full-stack TypeScript application with a client-server architecture.

### 1.1. Core Technologies

- **Programming Language:** TypeScript
- **Frontend:**
    - **UI Components:** LitElement
    - **Styling:** Tailwind CSS (via `@tailwind` directives in CSS) and PostCSS.
    - **Rendering:** HTML5 Canvas, with D3.js used for specific UI elements like the radial menu.
- **Backend:** Node.js, Express.js
- **Real-time Communication:** WebSockets (`ws` library)
- **Serialization:** **JSON**. A custom replacer function is used with `JSON.stringify` to handle `BigInt` values. (Note: MessagePack is not used, contrary to previous documentation).
- **Game State Archiving:** S3-Compatible Object Storage (Cloudflare R2 is referenced in the code).
- **Architecture:** Master/Worker architecture for scalability, with a Web Worker on the client-side for simulating single-player/replay games.

## 2. Project Structure

The project is organized into several key directories. The following structure is derived from the provided code files:

```
src/
├── client/                     # Frontend application
│   ├── components/             # Reusable UI components (LitElement)
│   │   ├── baseComponents/
│   │   │   └── setting/
│   │   ├── Difficulties.ts
│   │   ├── Maps.ts
│   │   └── NewsButton.ts
│   ├── data/
│   │   └── countries.json      # Data for flag selection
│   ├── graphics/               # Handles all rendering to the HTML5 Canvas
│   │   ├── fx/                 # Visual effects (Nuke, explosions)
│   │   ├── icons/              # SVG-based LitElement icons
│   │   └── layers/             # Core rendering layers (Terrain, Units, UI)
│   ├── styles/                 # CSS files (including Tailwind directives)
│   └── utilities/              # Client-side helper functions
├── core/                       # Shared game logic (client and server)
│   ├── configuration/          # Game configuration files and themes
│   ├── execution/              # Game actions (Executions)
│   │   ├── alliance/
│   │   └── utils/
│   ├── game/                   # Core game model (Game, Player, Unit, etc.)
│   ├── pathfinding/            # A* pathfinding and related utilities
│   ├── utilities/              # Shared utility functions
│   ├── validations/            # Input validation logic (e.g., username)
│   └── worker/                 # Web Worker implementation for client-side game logic
├── scripts/                    # Utility scripts
│   └── terrain/                # Scripts for generating terrain maps
└── server/                     # Backend Node.js application
    ├── gatekeeper/             # Security middleware (stubbed in this code)
    └── (Master.ts, Worker.ts, etc.)
```

### 2.1. `src` Directory Deep Dive

#### 2.1.1. `src/client` - The Frontend

- **`Main.ts`**: The main entry point for the client. Initializes UI components, event listeners, and handles the initial lobby joining logic.
- **`ClientGameRunner.ts`**: The core class that manages a running game instance on the client. It orchestrates the `GameRenderer`, `InputHandler`, `Transport`, and the client-side `WorkerClient`.
- **`Transport.ts`**: Handles all network communication (both WebSocket and LocalServer emulation) and translates UI events into game `Intents`.
- **`InputHandler.ts`**: Captures raw mouse, keyboard, and touch events and translates them into semantic `GameEvent`s (e.g., `MouseUpEvent`, `ZoomEvent`) on the `EventBus`.
- **`graphics/`**:
    - **`GameRenderer.ts`**: The main rendering class that orchestrates the drawing of all visual layers onto the canvas.
    - **`layers/`**: Each file defines a distinct visual layer, such as `TerrainLayer`, `UnitLayer`, `TerritoryLayer`, and UI elements like `ControlPanel`, `Leaderboard`, and `RadialMenu`.
- **`components/`**: UI is built with LitElement. These are reusable custom HTML elements like `<host-lobby-modal>`, `<username-input>`, etc.

#### 2.1.2. `src/core` - The Shared Game Logic

This is the most critical part of the application, containing the deterministic game rules and state management.

- **`game/`**: The core game model.
    - **`Game.ts`**: Defines the interfaces for the game world.
    - **`GameImpl.ts`**: The concrete implementation of the `Game` interface. This is the "real" game engine that runs on the server and in the client's web worker.
    - **`GameView.ts`**: A read-only proxy of the game state used by the client's main thread for rendering. It prevents direct mutation of the game state from the UI.
- **`execution/`**: Defines all possible actions as "Executions".
    - Each file represents a specific action (e.g., `AttackExecution.ts`, `ConstructionExecution.ts`).
    - `ExecutionManager.ts` is responsible for creating these `Execution` objects from `Intents`.
- **`worker/`**:
    - **`Worker.worker.ts`**: The code that runs inside a Web Worker. It creates a `GameRunner` instance to run the simulation off the main thread.
    - **`WorkerClient.ts`**: The interface on the main thread for communicating with the Web Worker.

#### 2.1.3. `src/server` - The Backend

- **`Server.ts`**: The main entry point for the server, which decides whether to start a `Master` or `Worker` process based on the environment.
- **`Master.ts`**: The master process. It manages worker processes, handles lobby creation and discovery (e.g., the `/api/public_lobbies` endpoint), and routes connections to the appropriate worker.
- **`Worker.ts`**: A worker process. It runs an Express server on a specific port and a `GameManager` to handle one or more game instances. It listens for WebSocket connections for the games it hosts.
- **`GameManager.ts`**: Manages the lifecycle of all `GameServer` instances within a single worker process.
- **`GameServer.ts`**: A server-side representation of a single game match. It manages connected `Client`s, processes turns, and handles the game loop via `setInterval`.

## 3. How the Game Works - A Deeper Technical Dive

### 3.1. The Game Loop

The game's loop is managed differently on the client and server.

- **Server-Side (`GameServer.ts`):** The game loop is driven by `setInterval`, which calls `endTurn()` at a regular interval (defined in `ServerConfig`). In each `endTurn`, it bundles all received `Intents` into a `Turn` object and broadcasts it to all connected clients.
- **Client-Side (`ClientGameRunner.ts`):** The client's main loop is driven by `requestAnimationFrame`. This loop is primarily for rendering (`renderer.tick()`) and keeping the Web Worker alive (`worker.sendHeartbeat()`). The actual game logic simulation is run inside the Web Worker.
- **Client-Side Web Worker (`Worker.worker.ts`):** The worker receives `heartbeat` messages from the main thread. Each heartbeat triggers `gameRunner.executeNextTick()`, which processes one tick of the game simulation. This keeps the simulation running smoothly without blocking the main rendering thread.

### 3.2. The Execution System: The Heart of the Game's Logic

Player actions are modeled as "Executions" for deterministic state updates.

1.  **Client Input (`InputHandler.ts`):** A raw user action (e.g., a right-click) is captured and published as a `GameEvent` (e.g., `ContextMenuEvent`) on the `EventBus`.
2.  **UI/Menu Logic (`RadialMenu.ts`):** A UI component, like the radial menu, listens for the `ContextMenuEvent`. When a menu option is clicked, it creates a high-level *intent event* (e.g., `SendAttackIntentEvent`).
3.  **Network Transport (`Transport.ts`):** The `Transport` class listens for these intent events. It converts them into plain data `Intent` objects (defined in `Schemas.ts`) and sends them to the server via WebSocket.
4.  **Server (`GameServer.ts`):** The server receives the `Intent`, adds it to a buffer for the current turn (`this.intents`).
5.  **Turn Processing (`GameServer.ts`):** At the end of a turn interval, the server bundles all intents into a `Turn` object and sends it back to all clients.
6.  **Client & Server Simulation (`Worker.worker.ts` & Server's `GameRunner`):** Both the server and each client's Web Worker receive the `Turn` object. They pass the intents to an `Executor` (`ExecutionManager.ts`), which creates concrete `Execution` classes (e.g., `new AttackExecution(...)`).
7.  **State Mutation (`GameImpl.ts`):** The `tick()` method of each `Execution` is called, which mutates the `Game` state. Because the process is identical on the server and all clients, the state remains synchronized.
8.  **Client-Side Update (`WorkerClient.ts` -> `ClientGameRunner.ts`):** The client's worker posts a `game_update` message back to the main thread. The `ClientGameRunner` receives this and updates its `GameView`, which in turn triggers the `GameRenderer` to redraw the screen.

### 3.3. Client-Server Communication

- **WebSockets:** Used for all real-time game communication.
- **JSON:** All messages are serialized using `JSON.stringify`. A custom `replacer` function in `Util.ts` handles the serialization of `BigInt` values to strings.
- **API Endpoints:** The server also exposes RESTful API endpoints for lobby management, fetching game records, and retrieving server environment settings.

### 3.4. Master/Worker Architecture: Scaling the Game

The server uses a master/worker architecture for scalability.

- **Master Process (`Master.ts`):** A single master process acts as the entry point. It doesn't run game logic. Its roles are:
    1.  Forking a pool of worker processes.
    2.  Scheduling public games by creating them on workers.
    3.  Providing an API endpoint (`/api/public_lobbies`) that aggregates lobby information from all workers.
    4.  Routing requests to the correct worker based on a hash of the `gameID` and a URL prefix (e.g., `/w0/`, `/w1/`).
- **Worker Processes (`Worker.ts`):**
    - Each worker is a complete Node.js/Express server running on a unique port.
    - It hosts multiple `GameServer` instances.
    - It handles all direct WebSocket and HTTP communication for the games it hosts.
    - This model isolates games and allows the application to utilize multiple CPU cores.

## 4. Advanced Topics & Codebase Quirks

### 4.1. The `Game` vs. `GameView` & The Web Worker

The separation of game logic is a key architectural pattern:

- **`Game` & `GameImpl`**: The full, mutable, authoritative game state.
    - On the **server**, it's the single source of truth.
    - On the **client**, it runs *inside the Web Worker* (`Worker.worker.ts`) to perform simulation without blocking the UI.
- **`GameView`**: A read-only proxy/view model of the game state.
    - It exists **only on the client's main thread**.
    - It gets its data from `game_update` messages sent by the client's Web Worker.
    - All rendering code (`graphics/layers/`) and UI components (`components/`) interact with the `GameView`, not the `Game`. This prevents the UI from accidentally mutating the state.

### 4.2. Configuration System

- **`src/core/configuration`**: This directory contains the configuration logic.
- **`ServerConfig`**: Defines server-level settings (ports, environment, auth tokens). Implementations exist for `Dev`, `Preprod`, and `Prod`.
- **`Config`**: Defines game-level settings (rules, speeds, costs). `DefaultConfig` is the main implementation.
- **`GameConfig` (in `Schemas.ts`):** A plain data object that defines the settings for a *specific match* (e.g., map, difficulty, player count). This is passed around to initialize the `Config` object.
- The client fetches the server's environment via `/api/env` to ensure it loads the matching configuration files.

### 4.3. LitElement and Styling

- **Light DOM:** Most LitElement components in this project use `createRenderRoot() { return this; }`. This disables the Shadow DOM, making it easy for global styles from `styles.css` (including Tailwind's utility classes) to apply to the components.
- **Tailwind CSS:** Styling is primarily done via utility classes in the Lit `html` templates.

### 4.4. `PseudoRandom` for Determinism

The `PseudoRandom` class (`src/core/PseudoRandom.ts`) is used throughout the `core` game logic instead of `Math.random()`. It's a simple Linear Congruential Generator (LCG) that, given the same initial seed, will always produce the same sequence of "random" numbers. This is absolutely essential for keeping the game simulation deterministic across all clients and the server.

### 4.5. The `EventBus`

The client-side code makes heavy use of a simple `EventBus` (`src/core/EventBus.ts`). This is used to decouple components. For example:
- `InputHandler` fires a `ContextMenuEvent`.
- `RadialMenu` listens for `ContextMenuEvent` to show itself.
- `RadialMenu` fires a `SendAttackIntentEvent`.
- `Transport` listens for `SendAttackIntentEvent` to send the data to the server.
This pattern prevents direct dependencies between components like `InputHandler` and `Transport`.